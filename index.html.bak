<!doctype html>
<html lang="en">

<head>
    <title>Vanishree ma'am's Website</title>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS v5.2.0-beta1 -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/css/bootstrap.min.css"
        integrity="sha384-0evHe/X+R7YkIZDRvuzKMRqM+OrBnVFBL6DOitfPri4tjfHxaWutUpFmBp4vmVor" crossorigin="anonymous">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@100;300;400;700&display=swap"
        rel="stylesheet">
    <style>
        body {
            font-family: "Times New Roman", Times, serif; 
        }
    </style>
</head>

<body class="h-100">
    

        <div class="container-fluid px-0 d-flex align-items-center justify-content-center"
            style="height: 100vh;position: relative;overflow: hidden;background: black;z-index: 0;">
            <!--<img id="topImg" src="bg.svg" class="d-md-none"
                style="height: 400px;width:100%;position: absolute; bottom: -40%;z-index: 0;opacity: 1;"
                data-0="transform:rotate(0deg) scale(2)" data-5000="transform:rotate(360deg) scale(8)">
            <img id="topImg" src="bg.svg" class="d-none d-md-block"
                style="height: 400px;width:100%;position: absolute;right: 0%;z-index: 0;opacity: 1;"
                data-0="transform:rotate(0deg) scale(2.6)" data-5000="transform:rotate(360deg) scale(8)">-->
			<img class="p-0" style="position: absolute; object-fit: cover;"
                src="top.jpg"
                alt="">
            <div class="px-3 px-md-5 text-center" style="z-index: 2">
                <h1 class="text-white fw-light display-2"><span class="fw-bold">VANISHREE RAO</span> </h1>
                <h3 class="text-white fw-bold">CRYPTOGRAPHER</h3>
                <!--<a href="#registration" class="btn btn-light fw-bold mt-3">LEARN MORE</a> -->
            </div>
        </div>
        <div class="container" style="position: relative;">
            <div class="row text-center my-5" data-bottom-top="opacity: 0; transform: scale(0.7)"
                data-center-top="opacity: 1; transform: scale(1)">
                <h1>MY JOURNEY</h1>
            </div>
            <div class="row" data-bottom-top="opacity: 0" data-center-top="opacity: 1">
                <div class="col-md-12">
                    <div class="card card-fluid mb-3 border-0" data>
                        <div class="row g-0">
                            <div class="col-md-3">
                                <img style="width: 100%;object-fit: cover;"
                                    src="https://images.unsplash.com/photo-1660020519017-6e3a88320c33?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=880&q=80"
                                    class="img-fluid rounded" alt="...">
                            </div>
                            <div class="col-md-9">
                                <div class="card-body">
                                    <h3 class="card-title fw-bold">About</h3>
                                    <p class="card-text text-success fst-italic my-0">
                                        Date
                                    </p>
                                    <p class="text-muted mt-0">
                                        Sample Line
                                    </p>
                                    <!-- generate lorem ipsum -->

                                    <p class="card-text">I am a Cryptographer. I am passionate about Cryptography and
                                        its
                                        applications to cybersecurity.
                                        Solving problems, in general, rivets me. My background is theoretical
                                        cryptography
                                        and I am interested in solving real-world cybersecurity problems using the rigor
                                        of
                                        cryptography.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="row text-center mt-5 mb-3" data-bottom-top="opacity: 0; transform: scale(0.7)"
                data-center-top="opacity: 1; transform: scale(1)">
                <h1>MY INTERESTS</h1>
                <!--<p>Sample Filler Text</p>-->
            </div>
            <div class="row text-center mt-5 mb-3" data-bottom-top="opacity: 0" data-center-top="opacity: 1">
                <div id="carousel" class="carousel slide carousel-dark" data-bs-ride="carousel">
                    <div class="carousel-inner">
                        <div class="carousel-item active">
                            <img style="object-fit: cover; height: 300px;width: 100%;" src="web3.jpg" alt="WEB 3">
                            <p> WEB 3</p>
                        </div>
                        <div class="carousel-item">
                            <img style="object-fit: cover; height: 300px;width: 100%;" src="blockchain.jpg"
                                alt="BLOCKCHAIN">
                            <p> BLOCKCHAIN </p>
                        </div>
                        <div class="carousel-item">
                            <img style="object-fit: cover; height: 300px;width: 100%;" src="NFT.jpg" alt="NFT">
                            <p> NFT </p>
                        </div>
                        <div class="carousel-item">
                            <img style="object-fit: cover; height: 300px;width: 100%;" src="cryptography.jpg"
                                alt="INFORMATION SECURITY">
                            <p> INFORMATION SECURITY </p>
                        </div>
                    </div>
                    <button class="carousel-control-prev" type="button" data-bs-target="#carousel"
                        data-bs-slide="prev">
                        <span class="carousel-control-prev-icon" aria-hidden="true"></span>
                        <span class="visually-hidden">Previous</span>
                    </button>
                    <button class="carousel-control-next" type="button" data-bs-target="#carousel"
                        data-bs-slide="next">
                        <span class="carousel-control-next-icon" aria-hidden="true"></span>
                        <span class="visually-hidden">Next</span>
                    </button>
                </div>
            </div>

            <div class="row text-center mt-5 mb-3"  data-bottom-top="opacity: 0; transform: scale(0.7)"
                data-center-top="opacity: 1; transform: scale(1)">
                <h1>PAPERS PUBLISHED</h1>
               <!-- <p>Sample Filler Text</p>-->
            </div>
            <div class="row mb-3"  >
                <div class="col-md-4 mb-3 " >
                    <div  class="card text-black bg-warning mb-3" >
                        <div class="card-body" style="width:100 px; font-family:  'Oswald', sans-serif; font-size: .9rem" >
                            <h4 class="card-title">Mina: Decentralized Cryptocurrency at Scale
                            </h4>

                            <p class="card-text">
                                <!-- Trigger Buttons HTML -->
                                <a href="https://docs.minaprotocol.com/static/pdf/technicalWhitepaper.pdf">Paper</a>
                                <button type="button" class="btn btn-primary ms-4" data-bs-toggle="collapse"
                                    data-bs-target="#myCollapse">Abstract</button>
                            </p>
                            <!-- Collapsible Element HTML -->
                            <div class="collapse " id="myCollapse">
                                <div class="card card-body">We introduce the notion of a succinct blockchain, a
                                    replicated
                                    state
                                    machine in which each state transition (block) can be efficiently verified in
                                    constant
                                    time regardless of the number of prior transitions in the
                                    system. Traditional blockchains require verification time linear in the
                                    number of transitions. We show how to construct a succinct blockchain
                                    using recursively composed succinct non-interactive arguments of knowledge (SNARKs).
                                    Finally, we instantiate this construction to implement
                                    Mina, a payment system (cryptocurrency) using a succinct blockchain.
                                    Mina offers payment functionality similar to Bitcoin, with a dramatically
                                    faster verification time of 200ms making it practical for lightweight clients
                                    and mobile devices to perform full verification of the system’s history.</div>
                            </div>

                        </div>
                    </div>
                </div>
                <div class="col-md-4 mb-3 ">
                    <div class=" card ">
                        <div class="card-body"  style="width:100 px;  font-family:  'Oswald', sans-serif; font-size: .9rem">
                            <h4 class="card-title">Coda: Decentralized Cryptocurrency at Scale
                            </h4>
                            <p class="card-text">
                                <!-- Trigger Buttons HTML -->
                                <a href="https://eprint.iacr.org/2020/352.pdf">Paper</a>
                                <button type="button" class="btn btn-primary ms-4" data-bs-toggle="collapse"
                                    data-bs-target="#myCollapse1">Abstract</button>
                            </p>
                            <div class="collapse" id="myCollapse1">
                                <div class="card card-body">We introduce the notion of a succinct blockchain, a
                                    replicated
                                    state
                                    machine in which each state transition (block) can be efficiently verified in
                                    constant
                                    time regardless of the number of prior transitions in the
                                    system. Traditional blockchains require verification time linear in the
                                    number of transitions. We show how to construct a succinct blockchain
                                    using recursively composed succinct non-interactive arguments of knowledge (SNARKs).
                                    Finally, we instantiate this construction to implement
                                    Mina, a payment system (cryptocurrency) using a succinct blockchain.
                                    Mina offers payment functionality similar to Bitcoin, with a dramatically
                                    faster verification time of 200ms making it practical for lightweight clients
                                    and mobile devices to perform full verification of the system’s history.</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-md-4 mb-3">
                    <div class="card text-black bg-info mb-3">
                        <div class="card-body"  style="width:100 px;  font-family:  'Oswald', sans-serif; font-size: .9rem">
                            <h4 class="card-title">Secure Two-Party Feature Selection 
                                Eldardiry,Shantanu Rane, Ryan A. Rossi, and Frank Torres</br></h4>
                            <p class="card-text">
                                <!-- Trigger Buttons HTML -->
                                <a href="https://arxiv.org/pdf/1901.00832.pdf">Paper</a>
                                <button type="button" class="btn btn-primary ms-4" data-bs-toggle="collapse"
                                    data-bs-target="#myCollapse2">Abstract</button>
                            </p>
                            <div class="collapse" id="myCollapse2">
                                <div class="card card-body">In this work, we study how to securely evaluate the value
                                    of trading data without requiring a trusted third party. We focus on
                                    the important machine learning task of classification. This leads us to
                                    propose a provably secure four-round protocol that computes the value
                                    of the data to be traded without revealing the data to the potential
                                    acquirer. The theoretical results demonstrate a number of important
                                    properties of the proposed protocol. In particular, we prove the security
                                    of the proposed protocol in the honest-but-curious adversary model.</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-md-4 mb-3">
                    <div class="card text-black bg-warning mb-3">
                        <div class="card-body"  style="width:100 px; font-family:  'Oswald', sans-serif; font-size: .9rem">
                            <h4 class="card-title">Achieving Differential Privacy in Secure Multiparty Data Aggregation
                                Protocols on Star Networks
                            </h4>
                            <p class="card-text">
                                <!-- Trigger Buttons HTML -->
                                <a
                                    href="https://dl.acm.org/doi/abs/10.1145/3029806.3029829?casa_token=qpXF5WxXaekAAAAA%3A_MYPEKWk5xxeKSgQ_HGDIuYTYhNnXJ-WHONx4mqR6ji6o9aARyCl-gk0os2H43zybWa3UWeIXqPneA">Paper</a>
                                <button type="button" class="btn btn-primary ms-4" data-bs-toggle="collapse"
                                    data-bs-target="#myCollapse3">Abstract</button>
                            </p>
                            <div class="collapse" id="myCollapse3">
                                <div class="card card-body">We consider the problem of privacy-preserving data
                                    aggregation
                                    in a star network topology, i.e., several untrusting participants connected to a
                                    single
                                    aggregator. We require that the participants do not discover each other's data, and
                                    the
                                    service provider remains oblivious to each participant's individual contribution.
                                    Furthermore, the final result is to be published in a differentially private manner,
                                    i.e., the result should not reveal the contribution of any single participant to a
                                    (possibly external) adversary who knows the contributions of all other participants.
                                    In
                                    other words, we require a secure multiparty computation protocol that also
                                    incorporates
                                    a differentially private mechanism. Previous solutions have resorted to caveats such
                                    as
                                    postulating a trusted dealer to distribute keys to the participants, or introducing
                                    additional entities to withhold the decryption key from the aggregator, or relaxing
                                    the
                                    star topology by allowing pairwise communication amongst the participants. In this
                                    paper, we show how to obtain a noisy (differentially private) aggregation result
                                    using
                                    Shamir secret sharing and additively homomorphic encryption without these mitigating
                                    assumptions. More importantly, while we assume semi-honest participants, we allow
                                    the
                                    aggregator to be stronger than semi-honest, specifically in the sense that he can
                                    try to
                                    reduce the noise in the differentially private result.

                                    To respect the differential privacy requirement, collusions of mutually untrusting
                                    entities need to be analyzed differently from traditional secure multiparty
                                    computation:
                                    It is not sufficient that such collusions do not reveal the data of honest
                                    participants;
                                    we must also ensure that the colluding entities cannot undermine differential
                                    privacy by
                                    reducing the amount of noise in the final result. Our protocols avoid this by
                                    requiring
                                    that no entity -- neither the aggregator nor any participant -- knows how much noise
                                    a
                                    participant contributes to the final result. We also ensure that if a cheating
                                    aggregator tries to influence the noise term in the differentially private output,
                                    he
                                    can be detected with overwhelming probability.</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-md-4 mb-3">
                    <div class="card">
                        <div class="card-body"  style="width:100 px; font-family:  'Oswald', sans-serif; font-size: .9rem">
                            <h4 class="card-title">Adaptively Secure Multi-Party Computation from LWE (via Equivocal
                                FHE) </h4>
                            <p class="card-text">
                                <!-- Trigger Buttons HTML -->
                                <a href="https://link.springer.com/chapter/10.1007/978-3-662-49387-8_9">Paper</a>
                                <button type="button" class="btn btn-primary ms-4" data-bs-toggle="collapse"
                                    data-bs-target="#myCollapse4">Abstract</button>
                            </p>
                            <div class="collapse" id="myCollapse4">
                                <div class="card card-body">Adaptively secure Multi-Party Computation (MPC) is an
                                    essential
                                    and fundamental notion in cryptography. In this work, we construct Universally
                                    Composable (UC) MPC protocols that are adaptively secure against all-but-one
                                    corruptions
                                    based on LWE. Our protocols have a constant number of rounds and communication
                                    complexity dependant only on the length of the inputs and outputs (it is independent
                                    of
                                    the circuit size).

                                    Such protocols were only known assuming an honest majority. Protocols in the
                                    dishonest
                                    majority setting, such as the work of Ishai et al. (CRYPTO 2008), require
                                    communication
                                    complexity proportional to the circuit size. In addition, constant-round adaptively
                                    secure protocols assuming dishonest majority are known to be impossible in the
                                    stand-alone setting with black-box proofs of security in the plain model. Here, we
                                    solve
                                    the problem in the UC setting using a set-up assumption which was shown necessary in
                                    order to achieve dishonest majority.

                                    The problem of constructing adaptively secure constant-round MPC protocols against
                                    arbitrary corruptions is considered a notorious hard problem. A recent line of works
                                    based on indistinguishability obfuscation construct such protocols with near-optimal
                                    number of rounds against arbitrary corruptions. However, based on standard
                                    assumptions,
                                    adaptively secure protocols secure against even just all-but-one corruptions with
                                    near-optimal number of rounds are not known. However, in this work we provide a
                                    three-round solution based only on LWE and NIZK secure against all-but-one
                                    corruptions.

                                    In addition, Asharov et al. (EUROCRYPT 2012) and more recently Mukherjee and Wichs
                                    (ePrint 2015) presented constant-round protocols based on LWE which are secure only
                                    in
                                    the presence of static adversaries. Assuming NIZK and LWE their static protocols run
                                    in
                                    two rounds where the latter one is only based on a common random string. Assuming
                                    adaptively secure UC NIZK, proposed by Groth et al. (ACM 2012), and LWE as mentioned
                                    above our adaptive protocols run in three rounds.

                                    Our protocols are constructed based on a special type of cryptosystem we call
                                    equivocal
                                    FHE from LWE. We also build adaptively secure UC commitments and UC zero-knowledge
                                    proofs (of knowledge) from LWE. Moreover, in the decryption phase using an AMD code
                                    mechanism we avoid the use of ZK and achieve communication complexity that does not
                                    scale with the decryption circuit.</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-md-4 mb-3">
                    <div class="card text-black bg-info mb-3">
                        <div class="card-body"  style="width:100 px; font-family:  'Oswald', sans-serif; font-size: .9rem">
                            <h4 class="card-title">Standard Security Does Not Imply Indistinguishability Under Selective
                                Opening </h4>
                            <p class="card-text">
                                <!-- Trigger Buttons HTML -->
                                <a href="https://link.springer.com/chapter/10.1007/978-3-662-53644-5_5">Paper</a>
                                <button type="button" class="btn btn-primary ms-4" data-bs-toggle="collapse"
                                    data-bs-target="#myCollapse5">Abstract</button>
                            </p>
                            <div class="collapse" id="myCollapse5">
                                <div class="card card-body">In a selective opening attack (SOA) on an encryption scheme,
                                    the
                                    adversary is given a collection of ciphertexts and she selectively chooses to see
                                    some
                                    subset of them “opened”, meaning that the messages and the encryption randomness are
                                    revealed to her. A scheme is SOA secure if the data contained in the unopened
                                    ciphertexts remains hidden. A fundamental question is whether every CPA secure
                                    scheme is
                                    necessarily also SOA secure. The work of Bellare et al. (EUROCRYPT’12) gives a
                                    partial
                                    negative answer by showing that some CPA secure schemes do not satisfy a
                                    simulation-based definition of SOA security called SIM-SOA. However, until now, it
                                    remained possible that every CPA-secure scheme satisfies an
                                    indistinguishability-based
                                    definition of SOA security called IND-SOA.

                                    In this work, we resolve the above question in the negative and construct a highly
                                    contrived encryption scheme which is CPA (and even CCA) secure but is not IND-SOA
                                    secure. In fact, it is broken in a very obvious sense by a selective opening attack
                                    as
                                    follows. A random value is secret-shared via Shamir’s scheme so that any t out of n
                                    shares reveal no information about the shared value. The n shares are individually
                                    encrypted under a common public key and the n resulting ciphertexts are given to the
                                    adversary who selectively chooses to see t of the ciphertexts opened.
                                    Counter-intuitively, by the specific properties of our encryption scheme, this
                                    suffices
                                    for the adversary to completely recover the shared value. Our contrived scheme
                                    relies on
                                    strong assumptions: public-coin differing inputs obfuscation and a certain type of
                                    correlation intractable hash functions.

                                    We also extend our negative result to the setting of SOA attacks with key opening
                                    (IND-SOA-K) where the adversary is given a collection of ciphertexts under different
                                    public keys and selectively chooses to see some subset of the secret keys.</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-md-4 mb-3">
                    <div class="card text-black bg-warning mb-3">
                        <div class="card-body"  style="width:100 px; font-family:  'Oswald', sans-serif; font-size: .9rem">
                            <h4 class="card-title">Adaptively-secure Multiparty Non-interactive Key Exchange </h4>
                            <p class="card-text">
                                <!-- Trigger Buttons HTML -->
                                <a
                                    href="https://escholarship.org/content/qt55g8v0ws/qt55g8v0ws_noSplash_145cd270e6e2652aee3816df30eaeca5.pdf">Paper</a>
                                <button type="button" class="btn btn-primary ms-4" data-bs-toggle="collapse"
                                    data-bs-target="#myCollapse6">Abstract</button>
                            </p>
                            <div class="collapse" id="myCollapse6">
                                <div class="card card-body">Non-interactive key exchange (NIKE) is a fundamental notion
                                    in
                                    Cryptography. This notion
                                    was introduced by Diffie and Hellman in 1976. They proposed the well-known 2-party
                                    NIKE protocol and left open the generic question of whether NIKE could be realized
                                    in
                                    the
                                    multiparty setting. NIKE has since then been an active area of research with an
                                    ultimate
                                    goal of obtaining best possible security in the multiparty setting. Although this
                                    has
                                    evaded
                                    researchers for many decades, advancements have been made through relaxations in
                                    multiple
                                    directions such as restricting to 3-parties, static/semi-static model (where the
                                    adversary
                                    needs to commit to the set of parties he wishes to be challenged upon ahead of
                                    time),
                                    random-oracle model, allowing initial setup, etc.
                                    This dissertation provides a solution to the open question: it provides a multiparty
                                    NIKE
                                    protocol that is adaptively secure with no setup and in the standard model.
                                    The solution employs novel techniques of using indistinguishability obfuscation,
                                    which
                                    are interesting in their own right and which seem promising in finding wider
                                    applications in
                                    other settings. One such technique pertains overcoming the somewhat inherent
                                    drawback of
                                    non-adaptivity of the puncturing technique introduced by Sahai and Waters.</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-md-4 mb-3">
                    <div class="card">
                        <div class="card-body"  style="width:100 px;  font-family:  'Oswald', sans-serif; font-size: .9rem">
                            <h4 class="card-title">Multi-party Key Exchange for Unbounded Parties from
                                Indistinguishability
                                Obfuscation </h4>

                            <p class="card-text">
                                <!-- Trigger Buttons HTML -->
                                <a href="https://link.springer.com/chapter/10.1007/978-3-662-48797-6_3">Paper</a>
                                <button type="button" class="btn btn-primary ms-4" data-bs-toggle="collapse"
                                    data-bs-target="#myCollapse7">Abstract</button>
                            </p>
                            <div class="collapse" id="myCollapse7">
                                <div class="card card-body">Existing protocols for non-interactive multi-party key
                                    exchange
                                    either (1) support a bounded number of users, (2) require a trusted setup, or (3)
                                    rely
                                    on knowledge-type assumptions.
                                    We construct the first non-interactive key exchange protocols which support an
                                    unbounded
                                    number of parties and have a security proof that does not rely on knowledge
                                    assumptions.
                                    Our non-interactive key-exchange protocol does not require a trusted setup and
                                    extends
                                    easily to the identity-based setting. Our protocols suffer only a polynomial loss to
                                    the
                                    underlying hardness assumptions.</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-md-4 mb-3">
                    <div class="card text-black bg-info mb-3">
                        <div class="card-body"  style="width:100 px; font-family:  'Oswald', sans-serif; font-size: .9rem">
                            <h4 class="card-title">Adaptively Secure, Universally Composable,
                                Multiparty Computation in Constant Rounds
                            </h4>
                            <p class="card-text">
                                <!-- Trigger Buttons HTML -->
                                <a
                                    href="https://link.springer.com/content/pdf/10.1007/978-3-662-46497-7_23.pdf">Paper</a>
                                <button type="button" class="btn btn-primary ms-4" data-bs-toggle="collapse"
                                    data-bs-target="#myCollapse8">Abstract</button>
                            </p>
                            <div class="collapse" id="myCollapse8">
                                <div class="card card-body">Cryptographic protocols with adaptive security ensure that
                                    security holds against an adversary who can dynamically determine which
                                    parties to corrupt as the protocol progresses—or even after the protocol
                                    is finished. In the setting where all parties may potentially be corrupted,
                                    and secure erasure is not assumed, it has been a long-standing open
                                    question to design secure-computation protocols with adaptive security
                                    running in constant rounds.
                                    Here, we show a constant-round, universally composable protocol for
                                    computing any functionality, tolerating a malicious, adaptive adversary
                                    corrupting any number of parties. Interestingly, our protocol can compute all
                                    functionalities, not just adaptively well-formed ones. The protocol relies on
                                    indistinguishability obfuscation, and assumes a common
                                    reference string.</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-md-4 mb-3">
                    <div class="card text-black bg-warning mb-3">
                        <div class="card-body"  style="width:100 px; font-family:  'Oswald', sans-serif; font-size: .9rem">
                            <h4 class="card-title">Standard Security Does Not Imply Indistinguishability Under Selective
                                Opening</h4>
                            <p class="card-text">
                                <!-- Trigger Buttons HTML -->
                                <a href="https://link.springer.com/chapter/10.1007/978-3-662-53644-5_5">Paper</a>
                                <button type="button" class="btn btn-primary ms-4" data-bs-toggle="collapse"
                                    data-bs-target="#myCollapse9">Abstract</button>
                            </p>
                            <div class="collapse" id="myCollapse9">
                                <div class="card card-body">In a selective opening attack (SOA) on an encryption scheme,
                                    the
                                    adversary is given a collection of ciphertexts and she selectively chooses to see
                                    some
                                    subset of them “opened”, meaning that the messages and the encryption randomness are
                                    revealed to her. A scheme is SOA secure if the data contained in the unopened
                                    ciphertexts remains hidden. A fundamental question is whether every CPA secure
                                    scheme is
                                    necessarily also SOA secure. The work of Bellare et al. (EUROCRYPT’12) gives a
                                    partial
                                    negative answer by showing that some CPA secure schemes do not satisfy a
                                    simulation-based definition of SOA security called SIM-SOA. However, until now, it
                                    remained possible that every CPA-secure scheme satisfies an
                                    indistinguishability-based
                                    definition of SOA security called IND-SOA.

                                    In this work, we resolve the above question in the negative and construct a highly
                                    contrived encryption scheme which is CPA (and even CCA) secure but is not IND-SOA
                                    secure. In fact, it is broken in a very obvious sense by a selective opening attack
                                    as
                                    follows. A random value is secret-shared via Shamir’s scheme so that any t out of n
                                    shares reveal no information about the shared value. The n shares are individually
                                    encrypted under a common public key and the n resulting ciphertexts are given to the
                                    adversary who selectively chooses to see t of the ciphertexts opened.
                                    Counter-intuitively, by the specific properties of our encryption scheme, this
                                    suffices
                                    for the adversary to completely recover the shared value. Our contrived scheme
                                    relies on
                                    strong assumptions: public-coin differing inputs obfuscation and a certain type of
                                    correlation intractable hash functions.

                                    We also extend our negative result to the setting of SOA attacks with key opening
                                    (IND-SOA-K) where the adversary is given a collection of ciphertexts under different
                                    public keys and selectively chooses to see some subset of the secret keys.</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-md-4 mb-3">
                    <div class="card">
                        <div class="card-body"  style="width:100 px; font-family:  'Oswald', sans-serif; font-size: .9rem">
                            <h4 class="card-title">Adaptive Security of Constrained PRFs </h4>
                            <p class="card-text">
                                <!-- Trigger Buttons HTML -->
                                <a
                                    href="https://link.springer.com/content/pdf/10.1007/978-3-662-45608-8_5.pdf">Paper</a>
                                <button type="button" class="btn btn-primary ms-4" data-bs-toggle="collapse"
                                    data-bs-target="#myCollapse10">Abstract</button>
                            </p>
                            <div class="collapse" id="myCollapse10">
                                <div class="card card-body">Constrained pseudorandom functions have recently been
                                    introduced
                                    independently by Boneh and Waters (Asiacrypt’13), Kiayias et
                                    al. (CCS’13), and Boyle et al. (PKC’14). In a standard pseudorandom
                                    function (PRF) a key k is used to evaluate the PRF on all inputs in the
                                    domain. Constrained PRFs additionally offer the functionality to delegate
                                    “constrained”
                                    keys kS which allow to evaluate the PRF only on a
                                    subset S of the domain.
                                    The three above-mentioned papers all show that the classical GGM
                                    construction (J.ACM’86) of a PRF from a pseudorandom generator
                                    (PRG) directly yields a constrained PRF where one can compute constrained keys to
                                    evaluate the PRF on all inputs with a given prefix. This
                                    constrained PRF has already found many interesting applications. Unfortunately, the
                                    existing security proofs only show selective security (by
                                    a reduction to the security of the underlying PRG). To achieve full security, one
                                    has to
                                    use complexity leveraging, which loses an exponential
                                    factor 2N in security, where N is the input length.
                                    The first contribution of this paper is a new reduction that only loses
                                    a quasipolynomial factor qlog N , where q is the number of adversarial
                                    queries. For this we develop a new proof technique which constructs a
                                    distinguisher by interleaving simple guessing steps and hybrid arguments
                                    a small number of times. This approach might be of interest also in other
                                    contexts where currently the only technique to achieve full security is
                                    complexity leveraging.
                                    Our second contribution is concerned with another constrained PRF,
                                    due to Boneh and Waters, which allows for constrained keys for the more
                                    general class of bit-fixing functions. Their security proof also suffers from
                                    a 2N loss, which we show is inherent. We construct a meta-reduction
                                    which shows that any “simple” reduction of full security from a noninteractive
                                    hardness
                                    assumption must incur an exponential security loss.</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-md-4 mb-3">
                    <div class="card text-black bg-info mb-3">
                        <div class="card-body"  style="width:100 px; font-family:  'Oswald', sans-serif; font-size: .9rem">
                            <h4 class="card-title">On Selective-Opening Attacks Against Encryption Schemes</h4>
                            <p class="card-text">
                                <!-- Trigger Buttons HTML -->
                                <a href="http://web.cs.ucla.edu/~rafail/PUBLIC/164.pdf">Paper</a>
                                <button type="button" class="btn btn-primary ms-4" data-bs-toggle="collapse"
                                    data-bs-target="#myCollapse11">Abstract</button>
                            </p>
                            <div class="collapse" id="myCollapse11">
                                <div class="card card-body">At FOCS’99, Dwork et al. put forth the notion of ‘selective-
                                    -opening attacks’ (SOAs, for short). In the literature, security against
                                    such attacks has been formalized via indistinguishability-based and
                                    simulation-based notions, respectively called IND-SO-CPA security and
                                    SIM-SO-CPA security. Furthermore, the IND-SO-CPA notion has been
                                    studied under two flavors – weak-IND-SO-CPA and full-IND-SO-CPA
                                    security. At Eurocrypt’09, Bellare et al. showed the first positive results
                                    on SOA security of encryption schemes: 1) any lossy encryption scheme is
                                    weak-IND-SO-CPA secure; 2) any lossy encryption scheme with efficient
                                    openability is SIM-SO--CPA secure.
                                    Despite rich further work on SOA security, the (un)feasibility of full-
                                    -IND-SO-CPA remains a major open problem in the area of SOA security.
                                    The elusive nature of the full-IND-SO-CPA notion of security is attributed
                                    to a specific aspect of the security game, namely, the challenger requiring
                                    to perform a super-polynomial time task. Not only do we not know
                                    whether there exists a scheme that is full-IND-SO-CPA secure, but we
                                    also do not know concrete attacks against popular schemes such as the
                                    ElGamal and Cramer-Shoup schemes in the full-IND-SO-CPA model.
                                    The contribution of our work is three-fold.
                                    1. Motivated by the difficulty in understanding (un)feasibility of the
                                    full-IND-SO-CPA notion, we study a variant of this notion that is
                                    closer in spirit to the IND-CPA notion but still embodies the security
                                    captured by the full-IND-SO-CPA notion. We observe that the weak
                                    form of our variation does not introduce any significant change to
                                    the weak-IND-SO-CPA notion; that is, the weak form of our notion
                                    is equivalent to the weak-IND-SO-CPA notion.
                                    2. Interestingly, we can show that a large class of encryption schemes can
                                    be proven insecure for the full form of our notion. The large class
                                    includes most known constructions of weak-IND-SO-CPA secure
                                    schemes and SIM-SO-CPA secure schemes and also popular schemes
                                    like the ElGamal and Cramer-Shoup schemes.
                                    3. Our third contribution studies the complexity of SIM-SO-CPA security.
                                    Complementing the result of Bellare et al., we show that lossiness is
                                    not necessary to achieve SIM-SO-CPA security. More specifically, we
                                    present a SIM-SO-CPA scheme that is not a lossy encryption scheme
                                    (regardless of efficient openability). Since SIM-SO-CPA security
                                    implies weak-IND-SO-CPA security, it follows as a corollary that
                                    the converses of both the implications proved by Bellare et al. do
                                    not hold. Furthermore, as a corollary of our techniques, on a slightly
                                    unrelated but useful note, we obtain that lossiness is not required
                                    to obtain non-committing encryption. Previously, at Eurocrypt’09,
                                    Fehr et al. showed a construction of a non-committing encryption
                                    scheme from trapdoor permutations and this scheme was, as noted
                                    by the authors, possibly not lossy. Our scheme amounts to the first
                                    construction of a non-committing encryption scheme that is provably
                                    not lossy.</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-md-4 mb-3">
                    <div class="card text-black bg-warning mb-3">
                        <div class="card-body" style="width:100 px; font-family:  'Oswald', sans-serif; font-size: .9rem">
                            <h4 class="card-title">Statistical Concurrent Non-malleable Zero Knowledge</h4>
                            <p class="card-text">
                                <!-- Trigger Buttons HTML -->
                                <a
                                    href="https://link.springer.com/content/pdf/10.1007/978-3-642-54242-8_8.pdf">Paper</a>
                                <button type="button" class="btn btn-primary ms-4" data-bs-toggle="collapse"
                                    data-bs-target="#myCollapse12">Abstract</button>
                            </p>
                            <div class="collapse" id="myCollapse12">
                                <div class="card card-body">The notion of Zero Knowledge introduced by Goldwasser,
                                    Micali and Rackoff in STOC 1985 is fundamental in Cryptography. Motivated by
                                    conceptual
                                    and practical reasons, this notion has been explored under stronger definitions. We
                                    will
                                    consider the following two
                                    main strengthened notions.
                                    <br>Statistical Zero Knowledge: here the zero-knowledge property will
                                    last forever, even in case in future the adversary will have unlimited
                                    power.</br>
                                    <br>Concurrent Non-Malleable Zero Knowledge: here the zeroknowledge property is
                                    combined
                                    with non-transferability and the
                                    adversary fails in mounting a concurrent man-in-the-middle attack
                                    aiming at transferring zero-knowledge proofs/arguments.</br>
                                    Besides the well-known importance of both notions, it is still unknown
                                    whether one can design a zero-knowledge protocol that satisfies both
                                    notions simultaneously.
                                    In this work we shed light on this question in a very strong sense.
                                    We show a statistical concurrent non-malleable zero-knowledge argument
                                    system for N P with a black-box simulator-extractor.</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-md-4 mb-3">
                    <div class="card">
                        <div class="card-body" style="width:100 px; font-family:  'Oswald', sans-serif; font-size: .9rem">
                            <h4 class="card-title">Adaptively Secure, Universally Composable,Multiparty Computation in
                                Constant Rounds</h4>
                            <p class="card-text">
                                <!-- Trigger Buttons HTML -->
                                <a
                                    href="https://link.springer.com/content/pdf/10.1007/978-3-662-46497-7_23.pdf">Paper</a>
                                <button type="button" class="btn btn-primary ms-4" data-bs-toggle="collapse"
                                    data-bs-target="#myCollapse13">Abstract</button>
                            </p>
                            <div class="collapse" id="myCollapse13">
                                <div class="card card-body">Cryptographic protocols with adaptive security ensure that
                                    security holds against an adversary who can dynamically determine which
                                    parties to corrupt as the protocol progresses—or even after the protocol
                                    is finished. In the setting where all parties may potentially be corrupted,
                                    and secure erasure is not assumed, it has been a long-standing open
                                    question to design secure-computation protocols with adaptive security
                                    running in constant rounds.
                                    Here, we show a constant-round, universally composable protocol for
                                    computing any functionality, tolerating a malicious, adaptive adversary
                                    corrupting any number of parties. Interestingly, our protocol can compute all
                                    functionalities, not just adaptively well-formed ones. The protocol relies on
                                    indistinguishability obfuscation, and assumes a common
                                    reference string.</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-md-4 mb-3">
                    <div class="card text-black bg-info mb-3">
                        <div class="card-body" style="width:100 px; font-family:  'Oswald', sans-serif; font-size: .9rem">
                            <h4 class="card-title">Adaptively Secure UC Constant Round Multi-Party Computation</h4>
                            <p class="card-text">
                                <!-- Trigger Buttons HTML -->
                                <a
                                    href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.690.843&rep=rep1&type=pdf">Paper</a>
                                <button type="button" class="btn btn-primary ms-4" data-bs-toggle="collapse"
                                    data-bs-target="#myCollapse14">Abstract</button>
                            </p>
                            <div class="collapse" id="myCollapse14">
                                <div class="card card-body">We present a universally composable multiparty computation
                                    protocol that is adaptively secure against corruption of n − 1 of the n players. The
                                    protocol has a constant number of
                                    rounds and communication complexity that depends only on the number of inputs and
                                    outputs
                                    (and not on the size of the circuit to be computed securely). Such protocols were
                                    already known
                                    for honest majority. However, adaptive security and constant round was known to be
                                    impossible in
                                    the stand-alone model and with black-box proofs of security. Here, we solve the
                                    problem
                                    in the UC
                                    model using a set-up assumption. Our protocol is secure assuming LWE is hard and
                                    achieved by
                                    building a special type of crypto system we call equivocal FHE from LWE. We also
                                    build
                                    adaptively
                                    secure and constant round UC commitment and zero-knowledge proofs (of knowledge)
                                    based
                                    on
                                    LWE.</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-md-4 mb-3">
                    <div class="card text-black bg-warning mb-3">
                        <div class="card-body" style="width:100 px; font-family:  'Oswald', sans-serif; font-size: .9rem">
                            <h4 class="card-title">Adaptive Security of Constrained PRFs</h4>
                            <p class="card-text">
                                <!-- Trigger Buttons HTML -->
                                <a
                                    href="https://link.springer.com/content/pdf/10.1007/978-3-662-45608-8_5.pdf">Paper</a>
                                <button type="button" class="btn btn-primary ms-4" data-bs-toggle="collapse"
                                    data-bs-target="#myCollapse15">Abstract</button>
                            </p>
                            <div class="collapse" id="myCollapse15">
                                <div class="card card-body">Constrained pseudorandom functions have recently been
                                    introduced
                                    independently by Boneh and Waters (Asiacrypt’13), Kiayias et
                                    al. (CCS’13), and Boyle et al. (PKC’14). In a standard pseudorandom
                                    function (PRF) a key k is used to evaluate the PRF on all inputs in the
                                    domain. Constrained PRFs additionally offer the functionality to delegate
                                    “constrained”
                                    keys kS which allow to evaluate the PRF only on a
                                    subset S of the domain.
                                    The three above-mentioned papers all show that the classical GGM
                                    construction (J.ACM’86) of a PRF from a pseudorandom generator
                                    (PRG) directly yields a constrained PRF where one can compute constrained keys to
                                    evaluate the PRF on all inputs with a given prefix. This
                                    constrained PRF has already found many interesting applications. Unfortunately, the
                                    existing security proofs only show selective security (by
                                    a reduction to the security of the underlying PRG). To achieve full security, one
                                    has to
                                    use complexity leveraging, which loses an exponential
                                    factor 2N in security, where N is the input length.
                                    The first contribution of this paper is a new reduction that only loses
                                    a quasipolynomial factor qlog N , where q is the number of adversarial
                                    queries. For this we develop a new proof technique which constructs a
                                    distinguisher by interleaving simple guessing steps and hybrid arguments
                                    a small number of times. This approach might be of interest also in other
                                    contexts where currently the only technique to achieve full security is
                                    complexity leveraging.
                                    Our second contribution is concerned with another constrained PRF,
                                    due to Boneh and Waters, which allows for constrained keys for the more
                                    general class of bit-fixing functions. Their security proof also suffers from
                                    a 2N loss, which we show is inherent. We construct a meta-reduction
                                    which shows that any “simple” reduction of full security from a noninteractive
                                    hardness
                                    assumption must incur an exponential
                                    security loss.</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-md-4 mb-3">
                    <div class="card">
                        <div class="card-body" style="width:100 px; font-family:  'Oswald', sans-serif; font-size: .9rem">
                            <h4 class="card-title">Adaptive Multiparty Non-interactive Key Exchange Without Setup In The
                                Standard Model</h4>
                            <p class="card-text">
                                <!-- Trigger Buttons HTML -->
                                <a href="https://eprint.iacr.org/2014/910.pdf">Paper</a>
                                <button type="button" class="btn btn-primary ms-4" data-bs-toggle="collapse"
                                    data-bs-target="#myCollapse16">Abstract</button>
                            </p>
                            <div class="collapse" id="myCollapse16">
                                <div class="card card-body">Introduced by Diffie and Hellman in 1976. They proposed the
                                    celebrated 2-party NIKE
                                    protocol and left open as a fascinating question, whether NIKE could be realized in
                                    the
                                    multiparty setting. NIKE has since then been an active area of research with an
                                    ultimate
                                    goal of
                                    obtaining best possible security in the multiparty setting. Although this has evaded
                                    researchers
                                    for many decades, advancements have been made through relaxations in multiple
                                    directions
                                    such
                                    as restricting to 3-parties, static/semi-static model (where the adversary needs to
                                    commit to the
                                    set of parties he wishes to be challenged upon ahead of time), random-oracle model,
                                    allowing
                                    initial setup, etc.
                                    In this work, we settle the longstanding open question: we present the first
                                    multiparty
                                    NIKE
                                    protocol that is adaptively secure with no setup and in the standard model.
                                    Our construction is based on indistinguishability obfuscation and
                                    obliviously-patchable
                                    puncturable pseudorandom functions, a new notion that we introduce.
                                    We employ novel techniques of using indistinguishability obfuscation, which are
                                    interesting
                                    in their own right and which we believe would find wider applications in other
                                    settings.
                                    One
                                    such technique pertains overcoming, the somewhat inherent, drawback of
                                    non-adaptivity of
                                    the
                                    puncturing technique introduced by Sahai and Waters [STOC’14]. Central to this
                                    technique
                                    is our new notion of obliviously-patchable puncturable pseudorandom functions. We
                                    present a
                                    concrete construction of these pseudorandom functions using multilinear maps and
                                    their
                                    recent
                                    approximations – the leveled-graded encoding schemes.
                                    Note that pseudorandom functions amount to an interactive assumption. We shall
                                    establish
                                    via a meta-reduction technique that, in natural settings, an interactive assumption
                                    is
                                    necessary
                                    (even with setup).</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-md-4 mb-3">
                    <div class="card text-black bg-info mb-3">
                        <div class="card-body" style="width:100 px; font-family:  'Oswald', sans-serif; font-size: .9rem">
                            <h4 class="card-title">An Auto-review Tool for Model-Based Testing of SafetyCritical
                                Systems</h4>
                            <p class="card-text">
                                <!-- Trigger Buttons HTML -->
                                <a
                                    href="https://dl.acm.org/doi/pdf/10.1145/2489280.2489294?casa_token=5gWnyzU9BjUAAAAA:KPv41qyNeESaczRVSzi0UoBFtQ-Cd4mCRMo54ZowOK6deRLs-tdXSSKhTWL5wNrRyZ7kKHu5OrJiS70">Paper</a>
                                <button type="button" class="btn btn-primary ms-4" data-bs-toggle="collapse"
                                    data-bs-target="#myCollapse17">Abstract</button>
                            </p>
                            <div class="collapse" id="myCollapse17">
                                <div class="card card-body">Verification of Test Procedures and Test Cases (TP, TC) is
                                    an
                                    important process stage for fulfilling the RTCA/DO-178B/C
                                    compliance objective while developing software for safety critical
                                    flight control systems. Correctness of these results, their
                                    requirement coverage (High/Low level) analysis and justified
                                    discrepancies (if any) are the primary objectives that must be
                                    satisfied. Manual reviews are the most common methods for
                                    achieving these objectives. This paper consolidates some of the
                                    past experiences while conducting manual reviews in the flight
                                    control software V&V for a commercial aircraft program.
                                    Through them a clear need and scope for automating portions of
                                    manual review is identified. This led to the development of an
                                    Auto-review Tool (ART) as we named it, which is qualified for
                                    claiming the certification credits. Since the tool automates
                                    portions within the verification process, it satisfies the 2nd
                                    criterion of tool qualification in RTCA/DO-178C standard for
                                    determining the tool qualification level. All the necessary
                                    documents such as Tool’s Operational Requirement (TOR), Tool
                                    Qualification Plan (TQP) and Tool Assessment Summary (TAS)
                                    are prepared. The paper presents the tool development process
                                    beginning with defining a library of Input/Output relation based
                                    functions for different control blocks, parser development and
                                    qualification activity that were performed by an independent
                                    testing team.</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-md-4 mb-3">
                    <div class="card text-black bg-warning mb-3">
                        <div class="card-body" style="width:100 px; font-family:  'Oswald', sans-serif; font-size: .9rem">
                            <h4 class="card-title">On the (In)security of Fischlin’s Paradigm </h4>
                            <p class="card-text">
                                <!-- Trigger Buttons HTML -->
                                <a
                                    href="https://link.springer.com/content/pdf/10.1007/978-3-642-36594-2_12.pdf">Paper</a>
                                <button type="button" class="btn btn-primary ms-4" data-bs-toggle="collapse"
                                    data-bs-target="#myCollapse18">Abstract</button>
                            </p>
                            <div class="collapse" id="myCollapse18">
                                <div class="card card-body">The Fiat-Shamir paradigm was proposed as a way to remove
                                    interaction from 3-round proof of knowledge protocols and derive secure
                                    signature schemes. This generic transformation leads to very efficient
                                    schemes and has thus grown quite popular. However, this transformation is proven
                                    secure
                                    only in the random oracle model. In FOCS 2003,
                                    Goldwasser and Kalai showed that this transformation is provably insecure in the
                                    standard model by presenting a counterexample of a 3-round
                                    protocol, the Fiat-Shamir transformation of which is (although provably
                                    secure in the random oracle model) insecure in the standard model, thus
                                    showing that the random oracle is uninstantiable. In particular, for every
                                    hash function that is used to replace the random oracle, the resulting signature
                                    scheme
                                    is existentially forgeable. This result was shown by relying
                                    on the non-black-box techniques of Barak (FOCS 2001).
                                    An alternative to the Fiat-Shamir paradigm was proposed by Fischlin in Crypto 2005.
                                    Fischlin’s transformation can be applied to any
                                    so called 3-round “Fiat-Shamir proof of knowledge’’ and can be used
                                    to derive non-interactive zero-knowledge proofs of knowledge as well as
                                    signature schemes. An attractive property of this transformation is that
                                    it provides online extractability (i.e., the extractor works without having to
                                    rewind
                                    the prover). Fischlin remarks that in comparison to the
                                    Fiat-Shamir transformation, his construction tries to “decouple the hash
                                    function from the protocol flow” and hence, the counterexample in the
                                    work of Goldwaaser and Kalai does not seem to carry over to this setting.
                                    In this work, we show a counterexample to the Fischlin’s transformation. In
                                    particular,
                                    we construct a 3-round Fiat-Shamir proof of knowledge (on which Fischlin’s
                                    transformation is applicable), and then, present
                                    an adversary against both - the soundness of the resulting non-interactive
                                    zero-knowledge, as well as the unforegeability of the resulting signature
                                    scheme. Our attacks are successful except with negligible probability for
                                    any hash function, that is used to instantiate the random oracle, provided
                                    that there is an apriori (polynomial) bound on the running time of the
                                    hash function. By choosing the right bound, secure instantiation of Fischlin
                                    transformation with most practical cryptographic hash functions
                                    can be ruled out.
                                    The techniques used in our work are quite unrelated to the ones used
                                    in the work of Goldwasser and Kalai. Our primary technique is to bind
                                    the protocol flow with the hash function if the code of the hash function
                                    is available. We believe that our ideas are of independent interest and
                                    maybe applicable in other related settings.</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-md-4 mb-3">
                    <div class="card">
                        <div class="card-body" style="width:100 px; font-family:  'Oswald', sans-serif; font-size: .9rem">
                            <h4 class="card-title">Revisiting Lower and Upper Bounds for Selective Decommitments</h4>
                            <p class="card-text">
                                <!-- Trigger Buttons HTML -->
                                <a
                                    href="https://link.springer.com/content/pdf/10.1007/978-3-642-36594-2_31.pdf">Paper</a>
                                <button type="button" class="btn btn-primary ms-4" data-bs-toggle="collapse"
                                    data-bs-target="#myCollapse19">Abstract</button>
                            </p>
                            <div class="collapse" id="myCollapse19">
                                <div class="card card-body">In [6,7], Dwork et al. posed the fundamental question of
                                    existence of commitment schemes that are secure against selective opening attacks
                                    (SOA,
                                    for short). In [2] Bellare, Hofheinz, and Yilek, and
                                    Hofheinz in [13] answered it affirmatively by presenting a scheme which
                                    is based solely on the non-black-box use of a one-way permutation needing a
                                    super-constant number of rounds. This result however opened other
                                    challenging questions about achieving a better round complexity and obtaining fully
                                    black-box schemes using underlying primitives and code of
                                    the adversary in a black-box manner.
                                    Recently, in TCC 2011, Xiao ([23]) investigated on how to achieve
                                    (nearly) optimal SOA-secure commitment schemes where optimality is
                                    in the sense of both the round complexity and the black-box use of
                                    cryptographic primitives. The work of Xiao focuses on a simulation-based
                                    security notion of SOA. Moreover, the various results in [23] focus only
                                    on either parallel or concurrent SOA.
                                    In this work we first point out various issues in the claims of [23]
                                    that actually re-open several of the questions left open in [2,13]. Then,
                                    we provide new lower bounds and concrete constructions that produce a
                                    very different state-of-the-art compared to the one claimed in [23].</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-md-4 mb-3">
                    <div class="card text-black bg-info mb-3">
                        <div class="card-body" style="width:100 px; font-family:  'Oswald', sans-serif; font-size: .9rem">
                            <h4 class="card-title">Round Optimal Blind Signatures</h4>
                            <p class="card-text">
                                <!-- Trigger Buttons HTML -->
                                <a
                                    href="https://link.springer.com/content/pdf/10.1007/978-3-642-22792-9_36.pdf">Paper</a>
                                <button type="button" class="btn btn-primary ms-4" data-bs-toggle="collapse"
                                    data-bs-target="#myCollapse20">Abstract</button>
                            </p>
                            <div class="collapse" id="myCollapse20">
                                <div class="card card-body">Constructing round-optimal blind signatures in the standard
                                    model has been a long standing open problem. In particular, Fischlin and
                                    Schröder recently ruled out a large class of three-move blind signatures
                                    in the standard model (Eurocrypt’10). In particular, their result shows
                                    that finding security proofs for the well-known blind signature schemes
                                    by Chaum, and by Pointcheval and Stern in the standard model via
                                    black-box reductions is hard. In this work we propose the first roundoptimal, i.e.,
                                    two-move, blind signature scheme in the standard model
                                    (i.e., without assuming random oracles or the existence of a common
                                    reference string). Our scheme relies on the Decisional Diffie Hellman
                                    assumption and the existence of sub-exponentially hard 1-to-1 one way
                                    functions. This scheme is also secure in the concurrent setting.</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-md-4 mb-3" >
                    <div class="card text-black bg-warning mb-3" >
                        <div class="card-body" style="width:100 px; font-family:  'Oswald', sans-serif; font-size: .9rem">
                            <h4 class="card-title">Correlated-Input Secure Hash Functions</h4>
                            <p class="card-text">
                                <!-- Trigger Buttons HTML -->
                                <a
                                    href="https://link.springer.com/content/pdf/10.1007/978-3-642-19571-6_12.pdf">Paper</a>
                                <button type="button" class="btn btn-primary ms-4" data-bs-toggle="collapse"
                                    data-bs-target="#myCollapse21">Abstract</button>
                            </p>
                            <div class="collapse" id="myCollapse21">
                                <div class="card card-body">We undertake a general study of hash functions secure under
                                    correlated inputs, meaning that security should be maintained when the
                                    adversary sees hash values of many related high-entropy inputs. Such
                                    a property is satisfied by a random oracle, and its importance is illustrated by
                                    study
                                    of the “avalanche effect,” a well-known heuristic in cryptographic hash function
                                    design.
                                    One can interpret “security” in different
                                    ways: e.g., asking for one-wayness or that the hash values look uniformly
                                    and independently random; the latter case can be seen as a generalization
                                    of correlation-robustness introduced by Ishai et al. (CRYPTO 2003). We
                                    give specific applications of these notions to password-based login and
                                    efficient search on encrypted data. Our main construction achieves them
                                    (without random oracles) for inputs related by polynomials over the input space
                                    (namely
                                    Zp), based on corresponding variants of the q-Diffie
                                    Hellman Inversion assumption. Additionally, we show relations between
                                    correlated-input secure hash functions and cryptographic primitives secure under
                                    related-key attacks. Using our techniques, we are also able to
                                    obtain a host of new results for such related-key attack secure cryptographic
                                    primitives.</div>
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </div>



<div class="container">

		<div class="row mb-4"  >
		<div class="row text-center mt-5 mb-4" data-bottom-top="opacity: 0; transform: scale(0.7)"
                data-center-top="opacity: 1; transform: scale(1)">
            <h1>MY BLOGS</h1>
            <!--<p>Sample Filler Text</p>-->
        </div>
	<div class="row row-cols-1 row-cols-md-3 g-4">
  <div class="col">
  <a href="blog1.html" class="btn btn">
    <div class="card h-100">
      <img src="zk.jpeg" class="card-img-top"
        alt="zkOracles" />
      <div class="card-body">
        <h5 class="card-title">zkOracles: A Savior against Large-scale Data Hacks</h5>
        <p class="card-text">
        <!--Published on Apr 15, 2022 -->
        </p>
      </div>
      <div class="card-footer">
        <small class="text-muted"><span class="fw-bold">Visit Blog</span></small>
      </div>
    </div></a>
  </div>
  <div class="col">
  <a href="blog9.html" class="btn btn">
    <div class="card h-100">
      <img src="blog9.jpg" class="card-img-top"
        alt="End-to-end Encryption" />
      <div class="card-body">
        <h5 class="card-title">End-to-end Encryption, Today -- Loophole Closed or Moved?</h5>
        <p class="card-text"><!--Published on April 23, 2016-->
        </p>
      </div>
      <div class="card-footer">
        <small class="text-muted"><span class="fw-bold">Visit Blog</span></small>
      </div>
    </div></a>
  </div>
  <div class="col">
  <a href="blog8.html" class="btn btn">
    <div class="card h-100">
      <img src="blog8.jpg" class="card-img-top"
        alt="Privacy vs. End-to-end Encryption " />
      <div class="card-body">
        <h5 class="card-title">Differential Privacy vs. End-to-end Encryption – It’s Privacy vs. Privacy!</h5>
        <p class="card-text">
          <!--Published on October 14, 2016-->
        </p>
      </div>
      <div class="card-footer">
        <small class="text-muted"> <span class="fw-bold">Visit Blog</span></small>
      </div>
    </div></a>
  </div>
</div>
  </div>

</div>	
</div>	

<div class="container">

		<div class="row mb-4"  >
		<div class="row text-center mt-5 mb-4">
            <a href="blog.html" class="btn btn-secondary btn-lg btn-block">Find more blogs here</a>
            <!--<p>Sample Filler Text</p>-->
        </div>
</div>		
		
	<div class="container">
	<div class="row mb-4">
            <div class="col-12 text-center mt-5 mb-3" data-bottom-top="opacity: 0; transform: scale(0.7)"
                data-center-top="opacity: 1; transform: scale(1)">
                <h1>CONTACT</h1>
				<p> I am always excited to chat about cryptography and cybersecurity. You can write to me on my email or connect with me on Twitter or LinkedIn. Let’s together push boundaries of cybersecurity with the power of cryptography.</p>
				
                <img style="position: center;height: 50 vh; width = 50%; top=0; bottom =0" src="email.png" class="img-fluid" alt="Responsive image">
				
				<a class="btn btn-primary" style="background-color: #55acee;" href="https://twitter.com/vanishree_rao?s=03" role="button"
  ><i class="fab fa-twitter me-2"></i>Twitter</a>
  
				<a class="btn btn-primary" style="background-color: #0082ca;" href="https://www.linkedin.com/in/vanishree-rao/" role="button"
  ><i class="fab fa-linkedin-in"></i>LinkedIn</a>
            </div>
    <div class="container">
        <footer class="d-flex flex-wrap justify-content-between align-items-center py-3 my-4 border-top">
            

            <ul class="nav col-md-4 justify-content-end list-unstyled d-flex">
      
						
				<div class="col-md-4 d-flex align-items-center">
                <span class="mb-3 mb-md-0 text-muted">© 2022 Company, Inc</span>
            </div>
            </ul>
        </footer>
    </div>
    </div>
</body>
<!-- Bootstrap JavaScript Libraries -->
<script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.5/dist/umd/popper.min.js"
    integrity="sha384-Xe+8cL9oJa6tN/veChSP7q+mnSPaj5Bcu9mPX5F5xIGE0DVittaqT5lorf0EI7Vk" crossorigin="anonymous">
</script>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/js/bootstrap.min.js"
    integrity="sha384-kjU+l4N0Yf4ZOJErLsIcvOU2qSb74wXpOhqTvwVx3OElZRweTnQ6d31fXEoRD1Jy" crossorigin="anonymous">
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/skrollr/0.6.30/skrollr.min.js"
    integrity="sha512-A2+khatRDWHUE2VUtN4xUTkr1nc4YfDBw9Sg3ea6x0aRPfpcYieDZji4D2edDHy/yF5NsYzP7kL8sSM8s5EqCw=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script>
    var s = skrollr.init();
</script>

</html>

